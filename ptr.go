package goquic

import (
	"sync"
	"math"
)

// Generated by `ptr_gen.py ProofSource ProofVerifier ProofVerifyJob TaskRunner ServerWriter ClientWriter QuicDispatcher QuicServerSession GoQuicAlarm QuicServerStream QuicClientStream`
// Do not edit manually!


var proofSourcePtr = &ProofSourcePtr{pool: make(map[int64]*ProofSource)}

type ProofSourcePtr struct {
	sync.RWMutex
	pool  map[int64]*ProofSource
	index int64
}

func (p *ProofSourcePtr) Get(key int64) *ProofSource {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *ProofSourcePtr) Set(pt *ProofSource) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *ProofSourcePtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var proofVerifierPtr = &ProofVerifierPtr{pool: make(map[int64]*ProofVerifier)}

type ProofVerifierPtr struct {
	sync.RWMutex
	pool  map[int64]*ProofVerifier
	index int64
}

func (p *ProofVerifierPtr) Get(key int64) *ProofVerifier {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *ProofVerifierPtr) Set(pt *ProofVerifier) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *ProofVerifierPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var proofVerifyJobPtr = &ProofVerifyJobPtr{pool: make(map[int64]*ProofVerifyJob)}

type ProofVerifyJobPtr struct {
	sync.RWMutex
	pool  map[int64]*ProofVerifyJob
	index int64
}

func (p *ProofVerifyJobPtr) Get(key int64) *ProofVerifyJob {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *ProofVerifyJobPtr) Set(pt *ProofVerifyJob) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *ProofVerifyJobPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var taskRunnerPtr = &TaskRunnerPtr{pool: make(map[int64]*TaskRunner)}

type TaskRunnerPtr struct {
	sync.RWMutex
	pool  map[int64]*TaskRunner
	index int64
}

func (p *TaskRunnerPtr) Get(key int64) *TaskRunner {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *TaskRunnerPtr) Set(pt *TaskRunner) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *TaskRunnerPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var serverWriterPtr = &ServerWriterPtr{pool: make(map[int64]*ServerWriter)}

type ServerWriterPtr struct {
	sync.RWMutex
	pool  map[int64]*ServerWriter
	index int64
}

func (p *ServerWriterPtr) Get(key int64) *ServerWriter {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *ServerWriterPtr) Set(pt *ServerWriter) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *ServerWriterPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var clientWriterPtr = &ClientWriterPtr{pool: make(map[int64]*ClientWriter)}

type ClientWriterPtr struct {
	sync.RWMutex
	pool  map[int64]*ClientWriter
	index int64
}

func (p *ClientWriterPtr) Get(key int64) *ClientWriter {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *ClientWriterPtr) Set(pt *ClientWriter) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *ClientWriterPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var quicDispatcherPtr = &QuicDispatcherPtr{pool: make(map[int64]*QuicDispatcher)}

type QuicDispatcherPtr struct {
	sync.RWMutex
	pool  map[int64]*QuicDispatcher
	index int64
}

func (p *QuicDispatcherPtr) Get(key int64) *QuicDispatcher {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *QuicDispatcherPtr) Set(pt *QuicDispatcher) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *QuicDispatcherPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var quicServerSessionPtr = &QuicServerSessionPtr{pool: make(map[int64]*QuicServerSession)}

type QuicServerSessionPtr struct {
	sync.RWMutex
	pool  map[int64]*QuicServerSession
	index int64
}

func (p *QuicServerSessionPtr) Get(key int64) *QuicServerSession {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *QuicServerSessionPtr) Set(pt *QuicServerSession) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *QuicServerSessionPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var goQuicAlarmPtr = &GoQuicAlarmPtr{pool: make(map[int64]*GoQuicAlarm)}

type GoQuicAlarmPtr struct {
	sync.RWMutex
	pool  map[int64]*GoQuicAlarm
	index int64
}

func (p *GoQuicAlarmPtr) Get(key int64) *GoQuicAlarm {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *GoQuicAlarmPtr) Set(pt *GoQuicAlarm) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *GoQuicAlarmPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var quicServerStreamPtr = &QuicServerStreamPtr{pool: make(map[int64]*QuicServerStream)}

type QuicServerStreamPtr struct {
	sync.RWMutex
	pool  map[int64]*QuicServerStream
	index int64
}

func (p *QuicServerStreamPtr) Get(key int64) *QuicServerStream {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *QuicServerStreamPtr) Set(pt *QuicServerStream) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *QuicServerStreamPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

var quicClientStreamPtr = &QuicClientStreamPtr{pool: make(map[int64]*QuicClientStream)}

type QuicClientStreamPtr struct {
	sync.RWMutex
	pool  map[int64]*QuicClientStream
	index int64
}

func (p *QuicClientStreamPtr) Get(key int64) *QuicClientStream {
	p.RLock()
	defer p.RUnlock()
	return p.pool[key]
}

func (p *QuicClientStreamPtr) Set(pt *QuicClientStream) int64 {
	p.Lock()
	defer p.Unlock()
	for {
		if _, ok := p.pool[p.index]; !ok {
			break
		}
		p.index += 1
		if p.index == math.MaxInt64 {
			p.index = 0
		}
	}
	p.pool[p.index] = pt
	p.index += 1
	return p.index - 1
}

func (p *QuicClientStreamPtr) Del(key int64) {
	p.Lock()
	defer p.Unlock()
	delete(p.pool, key)
}

